self := import("@platforma-sdk/workflow-tengo:tpl")
pt := import("@platforma-sdk/workflow-tengo:pt")
wf := import("@platforma-sdk/workflow-tengo:workflow")
ll := import("@platforma-sdk/workflow-tengo:ll")
smart := import("@platforma-sdk/workflow-tengo:smart")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pFrames := import("@platforma-sdk/workflow-tengo:pframes")
maps := import("@platforma-sdk/workflow-tengo:maps")
slices := import("@platforma-sdk/workflow-tengo:slices")
file := import("@platforma-sdk/workflow-tengo:file")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
pBuilder := import("@platforma-sdk/workflow-tengo:pframes.builder")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets := import("@platforma-sdk/workflow-tengo:assets")
json := import("json")
text := import("text")
math := import("math")
strings := import("@platforma-sdk/workflow-tengo:strings")

util := import(":util")

// Input headers
SAMPLE_KEY_HEADER := "sample_key"
CLONOTYPE_KEY_HEADER := "clonotype_key"

// Result headers
ANNOTATION_LABEL_HEADER := "label"

// Result file
DATA_FILE := "data.tsv"
STATS_FILE := "stats.tsv"

self.awaitState("columnBundle", { wildcard: "*" }, "ref", "ResourceReady")
self.awaitState("columnBundle", { wildcard: "*" }, "data", "InputsLocked")
self.awaitState("columnBundle", { wildcard: "*" }, "spec", "ResourceReady")

self.body(func(inputs) {
	blockId := inputs.blockId
	blockArgs := inputs.blockArgs
	columnBundle := inputs.columnBundle
	annotationSpecs := blockArgs.annotationSpecs

	anchorSpec := columnBundle.getColumn(blockArgs.inputAnchor).spec
	if len(anchorSpec.axesSpec) != 2 {
		ll.panic("Input anchor must have exactly 2 axes (sample, clonotype), found %d", len(anchorSpec.axesSpec))
	}
	sampleAxisSpec := anchorSpec.axesSpec[0]
	clonotypeAxisSpec := anchorSpec.axesSpec[1]

	mainFraction := columnBundle.getColumn(util.mainFractionColumn)
	if is_undefined(mainFraction) {
		ll.panic("Main abundance fraction column is required, but not found.")
	}

	mainFractionSpec := mainFraction.spec
	mainFractionData := mainFraction.data

	mainCount := columnBundle.getColumn(util.mainCountColumn)
	if is_undefined(mainCount) {
		ll.panic("Main count column is required, but not found.")
	}

	mainCountSpec := mainCount.spec
	mainCountData := mainCount.data

	outputs := {}

	if len(annotationSpecs.specs) == 0 {
		return outputs
	}

	// Preparing annotation script inputs
	specsColumns := util.extractColumnsFromExpression(annotationSpecs) // Already returns unique list

	numberOfColumns := len(specsColumns)

	tableBuilder := pFrames.tsvFileBuilder().cpu(1).mem(string(1 + numberOfColumns * 2) + "GiB")
	tableBuilder.setAxisHeader(clonotypeAxisSpec, CLONOTYPE_KEY_HEADER)

	headerMap := {}

	for colId in specsColumns {
		tableBuilder.add(columnBundle.getColumn(colId))
		header := tableBuilder.getHeader(colId)
		spec := tableBuilder.getSpec(colId)
		headerMap[colId] = header
	}

	finalExpressions := slices.map(annotationSpecs.specs, func(spec) {
		return {
			name: spec.name,
			expression: util.mapExpressionColumnNames(spec.expression, func(colId) {
				return headerMap[colId]
			})
		}
	})

	newColumnNames := slices.map(finalExpressions, func(spec) {
		return spec.name
	})

	addLabelColumn := pt.lit(undefined).alias(ANNOTATION_LABEL_HEADER)
	computeLabelColumn := slices.map(newColumnNames, func(colName) {
		return pt.when(pt.col(colName)).
			then(pt.lit(colName)).
			otherwise(pt.col(ANNOTATION_LABEL_HEADER)).
			alias(ANNOTATION_LABEL_HEADER)
	})

	sourceFile := tableBuilder.build()

	wf := pt.workflow()
	
	dfData := wf.frame(sourceFile, { format: "tsv" }).
		withColumns(finalExpressions...).
		addColumns(addLabelColumn).
		withColumns(computeLabelColumn...).
		select(CLONOTYPE_KEY_HEADER, ANNOTATION_LABEL_HEADER)

	// Save the data frame
	dfData.save(DATA_FILE)

	// Save the statistics
	dfData.
		groupBy(ANNOTATION_LABEL_HEADER).
		agg(
			pt.col(ANNOTATION_LABEL_HEADER).count().alias(ANNOTATION_LABEL_HEADER+"_count"),
			pt.col(CLONOTYPE_KEY_HEADER).count().alias(CLONOTYPE_KEY_HEADER+"_count")
		).
		save(STATS_FILE)

    // Run the defined workflow
    ptablerResult := wf.run()

	dataFile := ptablerResult.getFile(DATA_FILE)
	statsFile := ptablerResult.getFile(STATS_FILE)

	//
	// Converting result to PColumn
	//

	fullAxesSpec := [clonotypeAxisSpec]
	importAxesSpec := [{
		column: CLONOTYPE_KEY_HEADER,
		spec: { type: clonotypeAxisSpec.type }
	}]

	importedDataMap := xsv.importFile(dataFile, "tsv", {
		axes: importAxesSpec,
		columns: [ {
			column: ANNOTATION_LABEL_HEADER,
			spec: { valueType: "String" }
		} ],
		partitionKeyLength: 0,
		storageFormat: "Binary",
		mem: "12GiB",
		cpu: 1
	}, { dataOnly: true })

	annotationData := importedDataMap.getFutureInputField(ANNOTATION_LABEL_HEADER)

	annotationPfBuilder := pFrames.pFrameBuilder()

	trace := pSpec.makeTrace(anchorSpec, {
		type: "milaboratories.clonotype-annotation",
		label: annotationSpecs.title,
		importance: 20,
		id: blockId
	})
	annotationsColumnSpec := trace.inject({
		kind: "PColumn",
		valueType: "String",
		name: "pl7.app/vdj/annotation",
		domain: {
			"pl7.app/vdj/clonotypeAnnotationRunId": blockId
		},
		axesSpec: fullAxesSpec,
		annotations: {
			"pl7.app/label": annotationSpecs.title
		}
	})

	annotationPfBuilder.add("annotation", annotationsColumnSpec, annotationData)

	outputs["annotationPf"] = annotationPfBuilder.build()

	//
	// Exporting statistics
	//

	annotationsAxisSpec := {
		type: "String",
		name: "pl7.app/annotation",
		domain: {
			"pl7.app/clonotypeAnnotationRunId": blockId
		},
		annotations: {
			"pl7.app/label": annotationSpecs.title
		}
	}

	statsAxesSpec := [annotationsAxisSpec]

	statsImportSpec := {
		axes: [
			{ column: ANNOTATION_LABEL_HEADER, spec: annotationsAxisSpec }
		],
		columns: [
			{ column: ANNOTATION_LABEL_HEADER+"_count", spec: {
					valueType: "Long", 
					name: ANNOTATION_LABEL_HEADER+"_count",
					annotations: {
						"pl7.app/label": "Total Count of Annotations"
					}
				}
			},
			{ column: CLONOTYPE_KEY_HEADER+"_count", spec: { name: CLONOTYPE_KEY_HEADER+"_count", valueType: "Long", annotations: {
					"pl7.app/label": "Total Number of Clonotypes"
				} } }
		],
		partitionKeyLength: 0,
		storageFormat: "Binary"
	}

	statsImportedMap := xsv.importFile(statsFile, "tsv", statsImportSpec, { splitDataAndSpec: true, mem: "12GiB", cpu: 1 });

	statsPfBuilder := pFrames.pFrameBuilder()
	for k, v in statsImportedMap {
		statsPfBuilder.add(k, v.spec, v.data)
	}

	// labelCountData := statsImportedMap.getFutureInputField(ANNOTATION_LABEL_HEADER+"_count")
	// clonotypeKeyCountData := statsImportedMap.getFutureInputField(CLONOTYPE_KEY_HEADER+"_count")

	// labelCountSpec := trace.inject({
	// 	kind: "PColumn",
	// 	name: "pl7.app/vdj/stats/labelCount",
	// 	valueType: "Long",
	// 	axesSpec: statsAxesSpec,
	// 	annotations: {
	// 		"pl7.app/label": "Total Count of Annotations"
	// 	}
	// })

	// clonotypeKeyCountSpec := trace.inject({
	// 	kind: "PColumn",
	// 	name: "pl7.app/vdj/stats/clonotypeKeyCount",
	// 	valueType: "Long",
	// 	axesSpec: statsAxesSpec,
	// 	annotations: {
	// 		"pl7.app/label": "Total Number of Clonotypes"
	// 	}
	// })

	// statsPfBuilder := pFrames.pFrameBuilder()
	// statsPfBuilder.add("labelCount", labelCountSpec, labelCountData)
	// statsPfBuilder.add("clonotypeKeyCount", clonotypeKeyCountSpec, clonotypeKeyCountData)

	outputs["statsPf"] = statsPfBuilder.build()

	return outputs
})
