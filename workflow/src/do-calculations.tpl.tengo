self := import("@platforma-sdk/workflow-tengo:tpl")
ll := import("@platforma-sdk/workflow-tengo:ll")
smart := import("@platforma-sdk/workflow-tengo:smart")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pFrames := import("@platforma-sdk/workflow-tengo:pframes")
maps := import("@platforma-sdk/workflow-tengo:maps")
file := import("@platforma-sdk/workflow-tengo:file")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets := import("@platforma-sdk/workflow-tengo:assets")
json := import("json")

util := import(":util")

SAMPLE_KEY_HEADER := "sample_key"
CLONOTYPE_KEY_HEADER := "clonotype_key"

self.awaitState("columnBundle", { wildcard: "*" }, "data", "InputsLocked")
self.awaitState("columnBundle", { wildcard: "*" }, "spec", "ResourceReady")

annotatorSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-browser-2.annotator:main")

self.body(func(inputs) {
	blockId := inputs.blockId
	blockArgs := inputs.blockArgs
	columnBundle := inputs.columnBundle
	rawAnnotationScript := blockArgs.annotationScript

	anchorSpec := columnBundle.getColumn(blockArgs.inputAnchor).spec
	if len(anchorSpec.axesSpec) != 2 {
		ll.panic("Input anchor must have exactly 2 axes (sample, clonotype), found %d", len(anchorSpec.axesSpec))
	}

	sampleAxisSpec := anchorSpec.axesSpec[0]
	clonotypeAxisSpec := anchorSpec.axesSpec[1]
	mode := rawAnnotationScript.mode

	// Set global header overrides for key columns on the bundle
	columnBundle.setAxisHeader(clonotypeAxisSpec, CLONOTYPE_KEY_HEADER)
	columnBundle.setAxisHeader(sampleAxisSpec, SAMPLE_KEY_HEADER)

	scriptColumns := util.extractColumnsFromFilter(rawAnnotationScript) // Already returns unique list

	clonoTableBuilder := columnBundle.xsvTableBuilder()
	sampleTableBuilder := columnBundle.xsvTableBuilder()

	clonoSchemaMap := {}
	clonoSchemaMap[CLONOTYPE_KEY_HEADER] = { column: CLONOTYPE_KEY_HEADER, type: clonotypeAxisSpec.type }

	sampleSchemaMap := {}
	sampleSchemaMap[SAMPLE_KEY_HEADER] = { column: SAMPLE_KEY_HEADER, type: sampleAxisSpec.type }
	sampleSchemaMap[CLONOTYPE_KEY_HEADER] = { column: CLONOTYPE_KEY_HEADER, type: clonotypeAxisSpec.type }

	headerMap := {}

	needsClonoTable := (mode == "byClonotype")
	needsSampleTable := (mode == "bySampleAndClonotype")

	for colId in scriptColumns {
		colSpec := columnBundle.getSpec(colId)
		numAxes := len(colSpec.axesSpec)

		if numAxes == 1 {
			// Belongs in clonotype table
			clonoTableBuilder.add(colId)
			header := clonoTableBuilder.getHeader(colId)
			spec := clonoTableBuilder.getSpec(colId)
			clonoSchemaMap[header] = { column: header, type: spec.valueType }
			needsClonoTable = true // Mark true if any 1-axis col is used, even in bySample mode
			headerMap[colId] = header
		} else if numAxes == 2 {
			// Belongs in sample-clonotype table
			if mode == "byClonotype" {
				ll.panic("Column %s has 2 axes but mode is 'byClonotype'. The script expects only 1-axis columns in this mode.", colId)
			}
			sampleTableBuilder.add(colId)
			header := sampleTableBuilder.getHeader(colId)
			spec := sampleTableBuilder.getSpec(colId)
			sampleSchemaMap[header] = { column: header, type: spec.valueType }
			needsSampleTable = true
			headerMap[colId] = header
		} else {
			ll.panic("Column %s has an unexpected number of axes (%d), expected 1 or 2.", colId, numAxes)
		}
	}

	finalAnnotationScript := util.transformAnnotationScriptColumns(
		rawAnnotationScript,
		func(column) {
			return headerMap[column]
		}
	)

	// Setting the key columns for the script
	finalAnnotationScript.clonotypeKeyColumn = CLONOTYPE_KEY_HEADER
	if mode == "bySampleAndClonotype" {
		finalAnnotationScript.sampleKeyColumn = SAMPLE_KEY_HEADER
	}

	cmd := exec.builder().
		printErrStreamToStdout().
		software(annotatorSw)

	cmd.writeFile("script.json", json.encode(finalAnnotationScript))
	cmd.arg("--script").arg("script.json")

	if needsClonoTable {
		clonoTable := clonoTableBuilder.build("tsv")
		clonoSchema := maps.getValues(clonoSchemaMap)
		if len(clonoSchema) == 0 {
			ll.panic("Clonotype table is required by mode or columns, but the resulting table is empty.")
		}
		cmd.addFile("clonotype_properties.tsv", clonoTable)
		cmd.arg("--clonotype-data").arg("clonotype_properties.tsv")
		cmd.writeFile("clonotype_properties_schema.json", json.encode(clonoSchema))
		cmd.arg("--clonotype-schema").arg("clonotype_properties_schema.json")
	}

	if needsSampleTable {
		sampleTable := sampleTableBuilder.build("tsv")
		sampleSchema := maps.getValues(sampleSchemaMap)
		if len(sampleSchema) == 0 {
			ll.panic("Sample-clonotype table is required by mode, but the resulting table is empty.")
		}
		cmd.addFile("sample_clonotype_properties.tsv", sampleTable)
		cmd.arg("--sample-clonotype-data").arg("sample_clonotype_properties.tsv")
		cmd.writeFile("sample_clonotype_properties_schema.json", json.encode(sampleSchema))
		cmd.arg("--sample-clonotype-schema").arg("sample_clonotype_properties_schema.json")
	}

	cmd.saveFile("output.tsv")
	cmd.arg("--output").arg("output.tsv")

	taggerResult := cmd.run()
	processedResult := taggerResult.getFile("output.tsv")

	//
	// Converting result to PColumn
	//

	fullAxesSpec := [clonotypeAxisSpec]
	importAxesSpec := [{
		column: CLONOTYPE_KEY_HEADER,
		spec: { type: clonotypeAxisSpec.type }
	}]
	partitionKeyLength := 0

	if mode == "bySampleAndClonotype" {
		importAxesSpec = [{
			column: SAMPLE_KEY_HEADER,
			spec: { type: sampleAxisSpec.type }
		}] + importAxesSpec
		fullAxesSpec = [sampleAxisSpec] + fullAxesSpec
		partitionKeyLength = 1
	}

	importedDataMap := xsv.importFile(processedResult, "tsv", {
		axes: importAxesSpec,
		columns: [ {
			column: "label",
			spec: { valueType: "String" }
		} ],
		partitionKeyLength: partitionKeyLength,
		storageFormat: "Binary"
	}, { dataOnly: true })

	filterData := importedDataMap.getFutureInputField("label")

	pfBuilder := pFrames.pFrameBuilder()

	annotationSpec := {
		kind: "PColumn",
		name: "pl7.app/vdj/annotation",
		valueType: "String",
		axesSpec: fullAxesSpec,
		annotations: {
			"pl7.app/label": "Clonotype Annotations"
		}
	}

	trace := pSpec.makeTrace(anchorSpec, {
		type: "milaboratories.clonotype-browser-2",
		label: "Clonotype Annotation",
		importance: 20,
		id: blockId
	})
	annotationSpec = trace.inject(annotationSpec)

	pfBuilder.add("annotation", annotationSpec, filterData)

	return {
		result: pfBuilder.build()
	}
})
