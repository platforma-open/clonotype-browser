self := import("@platforma-sdk/workflow-tengo:tpl")
pt := import("@platforma-sdk/workflow-tengo:pt")
wf := import("@platforma-sdk/workflow-tengo:workflow")
ll := import("@platforma-sdk/workflow-tengo:ll")
smart := import("@platforma-sdk/workflow-tengo:smart")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pFrames := import("@platforma-sdk/workflow-tengo:pframes")
maps := import("@platforma-sdk/workflow-tengo:maps")
slices := import("@platforma-sdk/workflow-tengo:slices")
file := import("@platforma-sdk/workflow-tengo:file")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
pBuilder := import("@platforma-sdk/workflow-tengo:pframes.builder")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets := import("@platforma-sdk/workflow-tengo:assets")
json := import("json")
text := import("text")
math := import("math")
strings := import("@platforma-sdk/workflow-tengo:strings")

util := import(":util")

// Input headers
SAMPLE_KEY_HEADER := "sample_key"
CLONOTYPE_KEY_HEADER := "clonotype_key"

// Result headers
ANNOTATION_HEADER := "annotation"

// States headers
ANNOTATION_COUNT_HEADER := "annotation_count"
CLONOTYPE_COUNT_HEADER := "clonotype_count"

// Result file
DATA_FILE := "data.tsv"
STATS_FILE := "stats.tsv"

self.awaitState("columnBundle", { wildcard: "*" }, "ref", "ResourceReady")
self.awaitState("columnBundle", { wildcard: "*" }, "data", "InputsLocked")
self.awaitState("columnBundle", { wildcard: "*" }, "spec", "ResourceReady")

createAxisSpecFactory := func(blockId) {
	return func(type, name, label) {
		return {
			type: type,
			name: "pl7.app/clonotypeAnnotation/" + name,
			domain: {
				"pl7.app/clonotypeAnnotationRunId": blockId
			},
			annotations: {
				"pl7.app/label": label
			}
		}
	}
}

createColumnSpecFactory := func(trace, blockId) {
	return func(type, name, label, axesSpec) {
		return trace.inject({
			kind: "PColumn",
			valueType: type,
			name: "pl7.app/clonotypeAnnotation/" + name,
			domain: {
				"pl7.app/clonotypeAnnotationRunId": blockId
			},
			axesSpec: axesSpec,
			annotations: {
				"pl7.app/label": label
			}
		})
	}
}


convertToPFrame := func(dataAndSpec) {
	pf := pFrames.pFrameBuilder()
	for k, v in dataAndSpec {
		pf.add(k, v.spec, v.data)
	}
	return pf.build()
}

createStatsPFrameFactory := func(createAxisSpec, createColumnSpec, axisLabel) {
	return func(file) {
		annotationsAxisSpec := createAxisSpec("String", "annotation", axisLabel)
		statsAxesSpec := [annotationsAxisSpec]
		importSpec := {
			storageFormat: "Binary",
			partitionKeyLength: 0,
			axes: [
				{ column: ANNOTATION_HEADER, spec: annotationsAxisSpec }
			],
			columns: [
				{
					column: ANNOTATION_COUNT_HEADER,
					spec: createColumnSpec("Long", "stats/" + ANNOTATION_COUNT_HEADER, "Total Count of Annotations", statsAxesSpec)
				},
				{
					column: CLONOTYPE_COUNT_HEADER,
					spec: createColumnSpec("Long", "stats/" + CLONOTYPE_COUNT_HEADER, "Total Number of Clonotypes", statsAxesSpec)
				}
			]
		}

		statsDataAndSpec := xsv.importFile(file, "tsv", importSpec, { splitDataAndSpec: true });

		return convertToPFrame(statsDataAndSpec)
	}
}

createAnnotationPFrameFactory := func(clonotypeAxisSpec, createColumnSpec, annotationLabel) {
	return func(dataFile) {
		importSpec := {
			cpu: 1,
			mem: "12GiB",
			storageFormat: "Binary",
			partitionKeyLength: 0,
			axes: [{
				column: CLONOTYPE_KEY_HEADER,
				spec: clonotypeAxisSpec
			}],
			columns: [{
				column: ANNOTATION_HEADER,
				spec: createColumnSpec("String", "annotation", annotationLabel, [clonotypeAxisSpec])
			}]
		}

		dataAndSpec := xsv.importFile(dataFile, "tsv", importSpec, { splitDataAndSpec: true })

		return convertToPFrame(dataAndSpec)
	}
}

self.body(func(inputs) {
	blockId := inputs.blockId
	blockArgs := inputs.blockArgs
	columnBundle := inputs.columnBundle
	annotationSpecs := blockArgs.annotationSpecs

	outputs := {}

	if len(annotationSpecs.specs) == 0 {
		return outputs
	}

	anchorSpec := columnBundle.getColumn(blockArgs.inputAnchor).spec
	if len(anchorSpec.axesSpec) != 2 {
		ll.panic("Input anchor must have exactly 2 axes (sample, clonotype), found %d", len(anchorSpec.axesSpec))
	}
	sampleAxisSpec := anchorSpec.axesSpec[0]
	clonotypeAxisSpec := anchorSpec.axesSpec[1]

	mainFraction := columnBundle.getColumn(util.mainFractionColumn)
	if is_undefined(mainFraction) {
		ll.panic("Main abundance fraction column is required, but not found.")
	}

	mainFractionSpec := mainFraction.spec
	mainFractionData := mainFraction.data

	mainCount := columnBundle.getColumn(util.mainCountColumn)
	if is_undefined(mainCount) {
		ll.panic("Main count column is required, but not found.")
	}

	mainCountSpec := mainCount.spec
	mainCountData := mainCount.data

	trace := pSpec.makeTrace(anchorSpec, {
		type: "milaboratories.clonotype-annotation",
		label: annotationSpecs.title,
		importance: 20,
		id: blockId
	})

	createAxisSpec := createAxisSpecFactory(blockId)
	createColumnSpec := createColumnSpecFactory(trace, blockId)
	createStatsPFrame := createStatsPFrameFactory(createAxisSpec, createColumnSpec, annotationSpecs.title)
	createAnnotationPFrame := createAnnotationPFrameFactory(clonotypeAxisSpec, createColumnSpec, annotationSpecs.title)

	// Preparing annotation script inputs
	specsColumns := util.extractColumnsFromExpression(annotationSpecs)

	tableBuilder := pFrames.tsvFileBuilder().cpu(1).mem(string(1 + len(specsColumns) * 2) + "GiB")
	tableBuilder.setAxisHeader(clonotypeAxisSpec, CLONOTYPE_KEY_HEADER)
	for colId in specsColumns {
		tableBuilder.add(columnBundle.getColumn(colId))
	}
	sourceFile := tableBuilder.build()

	finalExpressions := slices.map(annotationSpecs.specs, func(spec) {
		return {
			name: spec.name,
			expression: util.mapExpressionColumnNames(spec.expression, func(colId) {
				return tableBuilder.getHeader(colId)
			})
		}
	})

	newColumnNamesReversed := slices.reverse(slices.map(finalExpressions, func(spec) {
		return spec.name
	}))

	annotationColumnExpr := slices.
		reduce(newColumnNamesReversed, func(acc, colName) {
			return pt.when(pt.col(colName)).then(pt.lit(colName))
		}, pt).
		otherwise(pt.lit(undefined)).
		alias(ANNOTATION_HEADER)

	wf := pt.workflow()
	
	dfData := wf.frame(sourceFile, { format: "tsv" }).
		withColumns(finalExpressions...).
		withColumns(annotationColumnExpr).
		select(CLONOTYPE_KEY_HEADER, ANNOTATION_HEADER)
	dfStats := dfData.
		groupBy(ANNOTATION_HEADER).
		agg(
			pt.col(ANNOTATION_HEADER).count().alias(ANNOTATION_COUNT_HEADER),
			pt.col(CLONOTYPE_KEY_HEADER).count().alias(CLONOTYPE_COUNT_HEADER)
		)

	dfData.save(DATA_FILE)
	dfStats.save(STATS_FILE)

    wfResult := wf.run()

	dataFile := wfResult.getFile(DATA_FILE)
	statsFile := wfResult.getFile(STATS_FILE)

	outputs["annotationPf"] = createAnnotationPFrame(dataFile);
	outputs["statsPf"] = createStatsPFrame(statsFile)

	return outputs
})
