json := import("json")
ll := import("@platforma-sdk/workflow-tengo:ll")
wf := import("@platforma-sdk/workflow-tengo:workflow")
smart := import("@platforma-sdk/workflow-tengo:smart")
file := import("@platforma-sdk/workflow-tengo:file")
assets := import("@platforma-sdk/workflow-tengo:assets")
render := import("@platforma-sdk/workflow-tengo:render")
pFrames := import("@platforma-sdk/workflow-tengo:pframes")

util := import(":util")
annotations := import(":annotations")
annotationsStats := import(":annotations-stats")

exportTableTpl := assets.importTemplate(":export-table")

wf.prepare(func(args) {
	return {
		columnBundle: is_undefined(args.inputAnchor) ? smart.createNullResource() : util.createColumnBundle(args)
	}
})

wf.body(func(args) {
	outputs := {
		tsvZip: smart.createNullResource()
	}
	exports := {}

	// Export TSVs

	if args.runExportAll {
		bundleBuilderForExport := wf.createPBundleBuilder()

		bundleBuilderForExport.addAnchor("main", args.inputAnchor)
		bundleBuilderForExport.addMulti({ axes: [{ anchor: "main", idx: 0 }, { anchor: "main", idx: 1 }] }, "perSample")
		bundleBuilderForExport.addMulti({ axes: [{ anchor: "main", idx: 1 }] }, "perClonotype")
		bundleBuilderForExport.addSingle({ name: "pl7.app/label", domainAnchor: "main", axes: [{ anchor: "main", idx: 0 }] }, "sampleLabels")
		
		// Add linker columns
		bundleBuilderForExport.addMulti({
			axes: [{ anchor: "main", idx: 1 }],
			annotations: { "pl7.app/isLinkerColumn": "true" },
			partialAxesMatch: true
		}, "linkers")

		// Add linked columns from args.tableInputs
		linkedColumns := {}
		linkedAxisCount := 0
		if !is_undefined(args.tableInputs) && !is_undefined(args.tableInputs.linkedColumns) {
			for anchorName, entry in args.tableInputs.linkedColumns {
				if !is_undefined(entry.anchorRef) && !is_undefined(entry.columns) {
					// Add anchor for this linker
					bundleBuilderForExport.addAnchor(entry.anchorName, entry.anchorRef)
					linkedColumns[anchorName] = {
						anchorRef: entry.anchorRef,
						columns: {},
						labels: {}
					}
					// Add each column from the columns map (query -> label)
					for colQueryStr, label in entry.columns {
						// Parse the JSON-serialized AnchoredPColumnSelector query
						colQuery := json.decode(colQueryStr)
						// Add the query to the bundle
						colName	:= "linkedAxis" + string(linkedAxisCount)
						bundleBuilderForExport.addSingle(colQuery, colName)
						linkedAxisCount += 1
						linkedColumns[anchorName].columns[colName] = colQuery
						// Store the label from model
						linkedColumns[anchorName].labels[colName] = label
					}
				}
			}
		}

		exportResult := render.createEphemeral(exportTableTpl, {
			columnBundle: bundleBuilderForExport.build(),
			inputAnchor: args.inputAnchor,
			linkedColumns: linkedColumns,
			byClonotypeLabels: args.tableInputs.byClonotypeLabels
		})

		outputs["tsvZip"] = exportResult.output("tsvZip")
		outputs["exportDebug"] = exportResult.output("exportDebug")
	}
	
	// Annotations computation

	annotationSpec := args.annotationSpec
	annotationAxesSpec := util.getAnnotationAxesSpec(args)

	if !is_undefined(args.inputAnchor) && !is_undefined(annotationAxesSpec) && len(annotationSpec.steps) > 0 {
		computedAnnotations := annotations.computeClonotypeAnnotations({
			title: annotationSpec.title,
			steps: annotationSpec.steps,
			inputAnchor: args.inputAnchor,
			defaultValue: annotationSpec.defaultValue,
			annotationAxesSpec: annotationAxesSpec,
			shouldComputeFilters: false
		})

		outputs["annotationsPf"] = pFrames.exportFrame(computedAnnotations.annotationsPf)

		if (!is_undefined(args.columnBundle)) {
			computedStats := annotationsStats.computeClonotypeAnnotationsStats({
				inputAnchor: args.inputAnchor,
				annotations: computedAnnotations.annotationsColumn,
				columnBundle: args.columnBundle
			})

			outputs["sampleStatsPf"] = pFrames.exportFrame(computedStats.sampleStatsPf)
			outputs["annotationStatsPf"] = pFrames.exportFrame(computedStats.annotationStatsPf)
		}
	}

	return {
		outputs: outputs,
		exports: exports
	}
})
