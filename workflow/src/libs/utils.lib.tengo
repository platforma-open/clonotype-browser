ll := import("@platforma-sdk/workflow-tengo:ll")
json := import("json")
text := import("text")
slices := import("@platforma-sdk/workflow-tengo:slices")

calculateLabels := func(includedTypesSet, enrichedColumns, force) {
	result := {}
	allUnique := true
	
	// Ensure we process ALL columns
	for enriched in enrichedColumns {
		includedTrace := []
		for entry in enriched.fullTrace {
			if !is_undefined(includedTypesSet[entry.fullType]) {
				includedTrace = append(includedTrace, entry)
			}
		}
		
		if len(includedTrace) == 0 {
			// If no trace entries match and not forcing, this combination fails
			if is_undefined(force) || !force {
				return undefined
			}
			// If forcing, use base label as fallback
			result[enriched.originalIndex] = enriched.baseLabel
		} else {
			// Join labels with " / " separator
			labelParts := []
			for entry in includedTrace {
				labelParts = append(labelParts, entry.label)
			}
			// Manual join implementation
			joined := ""
			for i, part in labelParts {
				if i > 0 {
					joined = joined + " / "
				}
				joined = joined + part
			}
			result[enriched.originalIndex] = joined
		}
	}
	
	// Check if all labels are unique
	labelSet := {}
	for _, label in result {
		if !is_undefined(labelSet[label]) {
			allUnique = false
			break
		}
		labelSet[label] = true
	}
	
	return {result: result, allUnique: allUnique}
}

// Derive unique labels from trace annotations for duplicate columns
// This implements a simplified version of the deriveLabels algorithm from UI SDK
// columns: array of column objects
// Returns: map from column index to derived label
deriveLabelsFromTrace := func(columns) {
	// Distance penalty for importance calculation (similar to UI algorithm)
	distancePenalty := 0.001
	
	// Collect all columns with their trace data
	enrichedColumns := []
	columnIndexMap := {} // Map column index to enriched column index
	
	for colIdx, col in columns {
		baseLabel := col.spec.annotations["pl7.app/label"]
		if is_undefined(baseLabel) {
			continue
		}
		
		// Parse trace annotation
		traceStr := col.spec.annotations["pl7.app/trace"]
		trace := []
		if !is_undefined(traceStr) {
			parsedTrace := json.decode(traceStr)
			if is_array(parsedTrace) {
				trace = parsedTrace
			}
		}
		// Build full trace with occurrence indices (type@1, type@2, etc.)
		// UI algorithm processes trace in reverse order but then reverses fullTrace at the end
		// So we need to process in reverse order to match UI behavior
		fullTrace := []
		occurrences := {} // Track occurrences of each type
		for i := len(trace) - 1; i >= 0; i -= 1 {
			entry := trace[i]
			typeName := entry.type
			importance := 0.0
			if !is_undefined(entry.importance) {
				importance = float(entry.importance)
			}
			
			occurrenceIndex := 1
			if !is_undefined(occurrences[typeName]) {
				occurrenceIndex = occurrences[typeName] + 1
			}
			occurrences[typeName] = occurrenceIndex
			
			fullType := typeName + "@" + string(occurrenceIndex)
			adjustedImportance := importance - float(len(trace) - i) * distancePenalty
			
			// Append to fullTrace (will be reversed later to match UI)
			fullTrace = append(fullTrace, {
				type: typeName,
				fullType: fullType,
				label: entry.label,
				importance: adjustedImportance,
				occurrenceIndex: occurrenceIndex
			})
		}
		
		// Reverse fullTrace to match UI behavior (UI reverses at the end)
		reversedFullTrace := []
		for i := len(fullTrace) - 1; i >= 0; i -= 1 {
			reversedFullTrace = append(reversedFullTrace, fullTrace[i])
		}
		fullTrace = reversedFullTrace
		
		// Add native label as trace entry if present (prepend like UI does)
		if !is_undefined(baseLabel) {
			labelEntry := {
				type: "__LABEL__",
				fullType: "__LABEL__@1",
				label: baseLabel,
				importance: -2.0,
				occurrenceIndex: 1
			}
			// Prepend label entry (like UI does with splice(0, 0, labelEntry))
			newFullTrace := [labelEntry]
			for elem in fullTrace {
				newFullTrace = append(newFullTrace, elem)
			}
			fullTrace = newFullTrace
		}
		
		enrichedColumns = append(enrichedColumns, {
			column: col,
			baseLabel: baseLabel,
			fullTrace: fullTrace,
			index: colIdx,
			originalIndex: colIdx
		})
		columnIndexMap[colIdx] = len(enrichedColumns) - 1
	}
	
	if len(enrichedColumns) == 0 {
		return {}
	}
	
	// Calculate importances and type counts
	importances := {}
	numberOfRecordsWithType := {}
	
	for enriched in enrichedColumns {
		for entry in enriched.fullTrace {
			fullType := entry.fullType
			currentImportance := importances[fullType]
			// UI uses Number.NEGATIVE_INFINITY as initial value
			// Use a very large negative number to approximate this
			if is_undefined(currentImportance) {
				currentImportance = -999999999.0
			}
			// UI uses Math.max to keep the highest importance
			if entry.importance > currentImportance {
				importances[fullType] = entry.importance
			}
			if is_undefined(numberOfRecordsWithType[fullType]) {
				numberOfRecordsWithType[fullType] = 0
			}
			numberOfRecordsWithType[fullType] += 1
		}
	}
	
	// Categorize types into main and secondary
	allTypeRecords := []
	for fullType, importance in importances {
		allTypeRecords = append(allTypeRecords, {fullType: fullType, importance: importance})
	}
	
	// Sort by importance (descending - highest first)
	// less function returns true if a should come before b
	// For descending: a should come before b if a.importance > b.importance
	// So less(a, b) should return a.importance > b.importance
	slices.quickSortInPlaceFn(allTypeRecords, func(a, b) {
		return a.importance > b.importance
	})

	mainTypes := []
	secondaryTypes := []
	
	for record in allTypeRecords {
		fullType := record.fullType
		if text.has_suffix(fullType, "@1") || numberOfRecordsWithType[fullType] == len(enrichedColumns) {
			mainTypes = append(mainTypes, fullType)
		} else {
			secondaryTypes = append(secondaryTypes, fullType)
		}
	}
	
	// UI algorithm: includeNativeLabel defaults to true in practice
	// UI includes __LABEL__@1 in mainTypes if it qualifies, then conditionally includes it
	// We'll always include it (matching UI behavior when includeNativeLabel=true)
	
	// Try to find minimal set of types that uniquely identify columns
	// Match UI algorithm exactly: while (includedTypes < mainTypes.length)
	// Tengo doesn't have while, so we use a for loop with a large upper bound
	includedTypes := 0
	additionalType := -1
	
	// Use for loop to simulate while (includedTypes < len(mainTypes))
	for includedTypes < len(mainTypes) {
		includedTypesSet := {}
		// Always include label type (matching UI when includeNativeLabel=true)
		includedTypesSet["__LABEL__@1"] = true
		
		// Add first includedTypes mainTypes (UI: for (let i = 0; i < includedTypes; ++i))
		for i := 0; i < includedTypes; i += 1 {
			if i < len(mainTypes) {
				includedTypesSet[mainTypes[i]] = true
			}
		}
		
		// Add additionalType if >= 0 (UI: if (additionalType >= 0))
		if additionalType >= 0 && additionalType < len(mainTypes) {
			includedTypesSet[mainTypes[additionalType]] = true
		}
		
		candidate := calculateLabels(includedTypesSet, enrichedColumns, false)
		// UI algorithm: check if labels uniquely separate records
		// candidateResult !== undefined && new Set(candidateResult.map((c) => c.label)).size === values.length
		// We need to check that we have exactly len(enrichedColumns) unique labels
		if !is_undefined(candidate) {
			// Count unique labels
			uniqueLabelCount := 0
			seenLabels := {}
			for _, label in candidate.result {
				if is_undefined(seenLabels[label]) {
					seenLabels[label] = true
					uniqueLabelCount += 1
				}
			}
			// Check if we have unique labels for all columns
			if uniqueLabelCount == len(enrichedColumns) && len(candidate.result) == len(enrichedColumns) {
				return candidate.result
			}
		}
		
		// UI algorithm: additionalType++; if (additionalType >= mainTypes.length) { includedTypes++; additionalType = includedTypes; }
		additionalType += 1
		if additionalType >= len(mainTypes) {
			includedTypes += 1
			additionalType = includedTypes
		}
	}
	
	// Fallback: use all main and secondary types
	fallbackSet := {}
	fallbackSet["__LABEL__@1"] = true
	for fullType in mainTypes {
		fallbackSet[fullType] = true
	}
	for fullType in secondaryTypes {
		fallbackSet[fullType] = true
	}
	
	fallbackResult := calculateLabels(fallbackSet, enrichedColumns, true)
	
	// Final safety check: ensure all input columns have labels
	finalLabels := {}
	if !is_undefined(fallbackResult) {
		finalLabels = fallbackResult.result
	}
	for colIdx, col in columns {
		if !is_undefined(col.spec.annotations["pl7.app/label"]) {
			if is_undefined(finalLabels[colIdx]) {
				// Missing label - use base label
				finalLabels[colIdx] = col.spec.annotations["pl7.app/label"]
			}
		}
	}
	
	// Final uniqueness check: if there are still duplicates, add suffixes
	labelCounts := {}
	labelOccurrences := {}
	uniqueLabels := {}
	
	// Count occurrences
	for colIdx, label in finalLabels {
		if is_undefined(labelCounts[label]) {
			labelCounts[label] = 0
		}
		labelCounts[label] += 1
	}
	
	// Add suffixes for duplicates
	for colIdx, label in finalLabels {
		if labelCounts[label] > 1 {
			if is_undefined(labelOccurrences[label]) {
				labelOccurrences[label] = 0
			}
			labelOccurrences[label] += 1
			if labelOccurrences[label] > 1 {
				uniqueLabels[colIdx] = label + " (" + string(labelOccurrences[label] - 1) + ")"
			} else {
				uniqueLabels[colIdx] = label
			}
		} else {
			uniqueLabels[colIdx] = label
		}
	}
	
	return uniqueLabels
}

export ll.toStrict({
	deriveLabelsFromTrace: deriveLabelsFromTrace
})

