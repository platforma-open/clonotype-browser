self := import("@platforma-sdk/workflow-tengo:tpl")
ll := import("@platforma-sdk/workflow-tengo:ll")
smart := import("@platforma-sdk/workflow-tengo:smart")
file := import("@platforma-sdk/workflow-tengo:file")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
maps := import("@platforma-sdk/workflow-tengo:maps")
slices := import("@platforma-sdk/workflow-tengo:slices")
math := import("math")
pt := import("@platforma-sdk/workflow-tengo:pt")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets := import("@platforma-sdk/workflow-tengo:assets")
utils := import(":libs.utils")

self.awaitState("columnBundle", "PColumnBundleWithPartitions")
self.awaitState("columnBundle", "sampleLabels", "ResourceReady")
self.awaitState("inputAnchor", "ResourceReady")

sevenZipSw := assets.importSoftware("@platforma-open/milaboratories.software-binary-collection.software-7zip:main")

cloneKeyAxisHeader := "clonotypeKey"

// Helper function to check if a column should be included in export
isValidColumn := func(col) {
	if col.spec.name == "pl7.app/vdj/sequence/annotation" {
		return false
	}
	if is_undefined(col.spec.annotations["pl7.app/label"]) {
		return false
	}
	return true
}

// Helper function to derive unique labels for columns
// Returns a map from column identifier/index to derived label
deriveLabelsForColumns := func(columnIdToColumnMap) {
	// Group columns by base label to identify duplicates
	columnsByLabel := {}
	for columnId, col in columnIdToColumnMap {
		baseLabel := col.spec.annotations["pl7.app/label"]
		if is_undefined(columnsByLabel[baseLabel]) {
			columnsByLabel[baseLabel] = []
		}
		columnsByLabel[baseLabel] = append(columnsByLabel[baseLabel], {columnId: columnId, column: col})
	}
	
	// Derive unique labels for duplicate columns using trace-based algorithm
	derivedLabels := {}
	columnsNeedingDerivation := []
	columnIdToDerivedIndexMap := {} // Map columnId to index in columnsNeedingDerivation array
	derivedIndexOffset := 0 // Track the offset for indices in columnsNeedingDerivation
	
	for baseLabel, colEntries in columnsByLabel {
		if len(colEntries) > 1 {
			// Multiple columns with same label - use trace-based derivation
			colsForDerivation := []
			for entry in colEntries {
				index := len(colsForDerivation)
				colsForDerivation = append(colsForDerivation, entry.column)
				columnIdToDerivedIndexMap[entry.columnId] = derivedIndexOffset + index
			}
			columnsNeedingDerivation += colsForDerivation
			derivedIndexOffset += len(colsForDerivation)
		} else {
			// Single column - use base label
			derivedLabels[colEntries[0].columnId] = baseLabel
		}
	}
	
	// Derive labels for duplicate columns
	if len(columnsNeedingDerivation) > 0 {
		traceDerivedLabels := utils.deriveLabelsFromTrace(columnsNeedingDerivation)
		// Map the derived labels back to column identifiers
		for columnId, derivedIndex in columnIdToDerivedIndexMap {
			derivedLabel := traceDerivedLabels[derivedIndex]
			if !is_undefined(derivedLabel) {
				derivedLabels[columnId] = derivedLabel
			}
		}
	}
	
	// Ensure all columns have labels (fallback to base label if missing)
	for columnId, col in columnIdToColumnMap {
		if is_undefined(derivedLabels[columnId]) {
			derivedLabels[columnId] = col.spec.annotations["pl7.app/label"]
		}
	}
	
	// Final check: ensure all derived labels are globally unique
	// This handles cases where columns with different base labels get the same trace-derived label
	labelCounts := {}
	labelOccurrences := {}
	finalDerivedLabels := {}
	
	// Count occurrences of each derived label
	for columnId, label in derivedLabels {
		if is_undefined(labelCounts[label]) {
			labelCounts[label] = 0
		}
		labelCounts[label] += 1
	}
	
	// Add suffixes for duplicates
	for columnId, label in derivedLabels {
		if labelCounts[label] > 1 {
			// This label appears multiple times, add suffix
			if is_undefined(labelOccurrences[label]) {
				labelOccurrences[label] = 0
			}
			labelOccurrences[label] += 1
			if labelOccurrences[label] > 1 {
				// Add numeric suffix starting from (1)
				finalDerivedLabels[columnId] = label + " (" + string(labelOccurrences[label] - 1) + ")"
			} else {
				// First occurrence keeps original label
				finalDerivedLabels[columnId] = label
			}
		} else {
			// Unique label, use as-is
			finalDerivedLabels[columnId] = label
		}
	}
	
	return finalDerivedLabels
}

// Helper function to ensure label uniqueness against used labels
// Returns the unique label (with suffix if needed) and updates usedLabelsSet
ensureUniqueLabel := func(label, usedLabelsSet) {
	if is_undefined(label) {
		return label
	}
	originalLabel := label
	suffixCount := 0
	for {
		if is_undefined(usedLabelsSet[label]) {
			break
		}
		suffixCount += 1
		label = originalLabel + " (" + string(suffixCount) + ")"
	}
	usedLabelsSet[label] = true // Mark this label as used
	return label
}

// Process linked columns and return frames and updated byCloneSpecs
processLinkedColumns := func(columnBundle, datasetSpec, linkedColumns, cloneKeyAxisHeader, bigTableWf, byCloneSpecs, usedLabels) {
	linkedFrames := []
	updatedByCloneSpecs := byCloneSpecs
	
	// Collect all linked columns from all linkers
	// Use column identifier from linkedColumns (the key in data.columns) as unique key
	columnIdMap := {} // Map column identifier to column object
	
	for linker, data in linkedColumns {
		for columnId, _ in data.columns {
			col := columnBundle.getColumn(columnId)
			if is_undefined(col) {
				continue
			}
			if !isValidColumn(col) {
				continue
			}
			columnIdMap[columnId] = col
		}
	}
	
	// Track labels already used by columnsPerClonotype to avoid conflicts
	usedLabelsSet := {}
	if !is_undefined(usedLabels) {
		for label in usedLabels {
			usedLabelsSet[label] = true
		}
	}
	
	// Derive unique labels for all linked columns
	derivedLabels := deriveLabelsForColumns(columnIdMap)
	
	// Ensure all derived labels are unique by adding suffixes if needed
	// This handles cases where trace-based algorithm produces same label for columns with different base labels
	// Also check against labels already used by columnsPerClonotype
	labelCounts := {}
	labelOccurrences := {}
	finalDerivedLabels := {}
	
	// Count occurrences of each derived label (skip undefined labels)
	for colName, label in derivedLabels {
		if is_undefined(label) {
			continue
		}
		if is_undefined(labelCounts[label]) {
			labelCounts[label] = 0
		}
		labelCounts[label] += 1
	}
	
	// Add suffixes for duplicates, also checking against usedLabelsSet
	for colName, label in derivedLabels {
		if is_undefined(label) {
			// Skip undefined labels - they will use base label as fallback
			continue
		}
		needsSuffix := false
		if labelCounts[label] > 1 {
			needsSuffix = true
		} else if !is_undefined(usedLabelsSet[label]) {
			// Label conflicts with already used label from columnsPerClonotype
			needsSuffix = true
		}
		
		if needsSuffix {
			// This label appears multiple times or conflicts, add suffix
			if is_undefined(labelOccurrences[label]) {
				labelOccurrences[label] = 0
			}
			labelOccurrences[label] += 1
			if labelOccurrences[label] > 1 {
				// Add numeric suffix starting from (1)
				finalDerivedLabels[colName] = label + " (" + string(labelOccurrences[label] - 1) + ")"
			} else {
				// First occurrence keeps original label if it doesn't conflict
				if is_undefined(usedLabelsSet[label]) {
					finalDerivedLabels[colName] = label
				} else {
					// Conflict with used label, add suffix
					finalDerivedLabels[colName] = label + " (" + string(labelOccurrences[label]) + ")"
					labelOccurrences[label] += 1
				}
			}
		} else {
			// Unique label, use as-is
			finalDerivedLabels[colName] = label
		}
	}
	
	derivedLabels = finalDerivedLabels
	
	for linker, data in linkedColumns {
		// Collect and filter linked columns for this linker
		linkedColsForLinker := []
		for name, _ in data.columns {
			col := columnBundle.getColumn(name)
			if is_undefined(col) {
				continue
			}
			if !isValidColumn(col) {
				continue
			}
			linkedColsForLinker = append(linkedColsForLinker, col)
		}
		
		// Sort linked columns by orderPriority (similar to columnsPerSample)
		slices.quickSortInPlaceFn(linkedColsForLinker, func(a, b) {
			if is_undefined(a.spec.annotations["pl7.app/table/orderPriority"]) {
				return false
			}
			if is_undefined(b.spec.annotations["pl7.app/table/orderPriority"]) {
				return true
			}
			return int(a.spec.annotations["pl7.app/table/orderPriority"]) > int(b.spec.annotations["pl7.app/table/orderPriority"])
		})
		
		// Skip if no valid linked columns after filtering
		if len(linkedColsForLinker) == 0 {
			continue
		}
		
		linkedTsvBuilder := pframes.tsvFileBuilder().cpu(1).mem("4GiB")
		linkedTsvBuilder.setAxisHeader(datasetSpec.axesSpec[1], cloneKeyAxisHeader)
		
		// Define cluster axis name for this linker
		clusterAxisName := "cluster_" + linker
		
		// Get the linker column using its anchorRef
		if !is_undefined(data.anchorRef) {
			linkerCol := columnBundle.getColumn(data.anchorRef)
			if !is_undefined(linkerCol) {
				// Add linker column (like in antibody-tcr-lead-selection lines 213-226)
				if datasetSpec.axesSpec[1].name == linkerCol.spec.axesSpec[1].name {
					linkedTsvBuilder.add(linkerCol, {header: "linker." + linker})
					linkedTsvBuilder.setAxisHeader(linkerCol.spec.axesSpec[0], clusterAxisName)
				} else if datasetSpec.axesSpec[1].name == linkerCol.spec.axesSpec[0].name {
					linkedTsvBuilder.add(linkerCol, {header: "linker." + linker})
					linkedTsvBuilder.setAxisHeader(linkerCol.spec.axesSpec[1], clusterAxisName)
				}
			}
		}
		
		// Add filtered and sorted linked columns with unique headers
		for name, _ in data.columns {
			col := columnBundle.getColumn(name)
			if is_undefined(col) {
				continue
			}
			if !isValidColumn(col) {
				continue
			}
			
			// Get derived label (from trace if duplicate, otherwise base label)
			// Use column identifier (name from data.columns) as key
			uniqueHeader := derivedLabels[name]
			
			// If no derived label (shouldn't happen), fallback to base label
			if is_undefined(uniqueHeader) {
				uniqueHeader = col.spec.annotations["pl7.app/label"]
			}
			
			// Final check for uniqueness against all used labels (including columnsPerClonotype)
			// Only add suffix if there's an actual conflict
			uniqueHeader = ensureUniqueLabel(uniqueHeader, usedLabelsSet)
			
			// Set axis headers for any axes that are not the main clonotypeKey axis
			for axisIdx, axis in col.spec.axesSpec {
				if axis.name != datasetSpec.axesSpec[1].name {
					axisHeaderName := clusterAxisName + "_" + string(axisIdx)
					linkedTsvBuilder.setAxisHeader(axis, axisHeaderName)
				}
			}
			
			linkedTsvBuilder.add(col, {header: uniqueHeader})
			// Update the spec's label to match the header we used
			updatedSpec := maps.clone(col.spec)
			updatedSpec.annotations["pl7.app/label"] = uniqueHeader
			updatedByCloneSpecs += [updatedSpec]
		}
		
		linkedTsv := linkedTsvBuilder.build()
		linkedFrames = append(linkedFrames, bigTableWf.frame(linkedTsv, { xsvType: "tsv", inferSchema: false }))
	}
	
	return {
		frames: linkedFrames,
		byCloneSpecs: updatedByCloneSpecs
	}
}

self.body(func(inputs) {
	columnBundle := inputs.columnBundle
	inputAnchor := inputs.inputAnchor
	linkedColumns := inputs.linkedColumns

	columnsPerSample := columnBundle.getColumns("perSample")
	columnsPerClonotype := columnBundle.getColumns("perClonotype")
	sampleLabels := columnBundle.getColumn("sampleLabels")
	sampleLabelsMap := sampleLabels.data.getDataAsJson().data

	byCloneSpecs := []
	bySampleSpecs := []

	//
	// Creating tsv files for each sample
	//

	slices.quickSortInPlaceFn(columnsPerSample, func(a, b) {
		if is_undefined(a.spec.annotations["pl7.app/table/orderPriority"]) {
			return false
		}
		if is_undefined(b.spec.annotations["pl7.app/table/orderPriority"]) {
			return true
		}
		return int(a.spec.annotations["pl7.app/table/orderPriority"]) > int(b.spec.annotations["pl7.app/table/orderPriority"])
	})
	partitionedColumnsPerSample := slices.map(columnsPerSample, func(column) {
		parsed := pframes.parseData(column)
		return parsed.partition(0)
	})
	partitionsPerSample := {}
	for partitioned in partitionedColumnsPerSample {
		maps.forEach(partitioned, func(key, partition) {
			if is_undefined(partitionsPerSample[key]) {
				partitionsPerSample[key] = []
			}
			partitionsPerSample[key] = append(partitionsPerSample[key], partition)
		})
	}

	// If no per-sample data, terminate early
	if len(partitionsPerSample) == 0 {
		return {
			tsvZip: smart.createNullResource()
		}
	}

	numberOfSamples := len(partitionsPerSample)

	perSampleTsvFiles := {}
	maps.forEach(partitionsPerSample, func(key, partitions) {
		builder := pframes.tsvFileBuilder().cpu(2).mem("12GiB")
		axisHeaderSet := false
		for partition in partitions {
			sampleLabel := sampleLabelsMap[key]
			ll.assert(!is_undefined(sampleLabel), "Expected sample label for " + key)
			spec := maps.deepTransform(partition.getSpec(), {
				annotations: {
					"pl7.app/label": func(label) {
						return label + " / " + sampleLabel
					}
				}
			})
			if !axisHeaderSet {
				builder.setAxisHeader(spec.axesSpec[0], cloneKeyAxisHeader)
				axisHeaderSet = true
			}
			bySampleSpecs += [spec]
			builder.add({
				spec: spec,
				data: partition.createDataResource()
			})
		}
		perSampleTsvFiles[key] = builder.build()
	})

	//
	// Creating the per-clonotype table
	//

	// perClonotypeTsvBuilder := pframes.tsvFileBuilder()
	// for column in columnsPerClonotype {
	// 	if column.spec.name == "pl7.app/vdj/sequence/annotation"{
	// 		continue
	// 	}
	// 	if is_undefined(column.spec.annotations["pl7.app/label"]) {
	// 		continue
	// 	}
	// 	byCloneSpecs += [column.spec]
	// 	perClonotypeTsvBuilder.add(column)
	// }
	// perClonotypeTsv := perClonotypeTsvBuilder.build()

	//
	// Creating the big table
	//

	bigTableWf := pt.workflow().
		cpu(math.max(numberOfSamples, 2)).
		mem(string(int(math.min(math.max(numberOfSamples, 2) * 8, 128))) + "GiB")
	// perClonotypePf := bigTableWf.frame(perClonotypeTsv, { xsvType: "tsv", inferSchema: false })

	pfs := []

	tsvBuilder := undefined
	columnsInBuilder := 0
	datasetSpec := columnBundle.getSpec(inputAnchor)
	columnIndex := 0
	
	// Filter and collect columnsPerClonotype
	filteredColumnsPerClonotype := []
	columnIndexMap := {} // Map column index to column object for label derivation
	for colIdx, column in columnsPerClonotype {
		if !isValidColumn(column) {
			continue
		}
		filteredColumnsPerClonotype = append(filteredColumnsPerClonotype, {column: column, originalIndex: colIdx})
		columnIndexMap[colIdx] = column
	}
	
	// Derive unique labels for columnsPerClonotype
	derivedLabels := deriveLabelsForColumns(columnIndexMap)
	
	// Track labels used to ensure global uniqueness
	usedLabelsSet := {}
	
	// Add columns with derived labels
	for filteredIdx, colEntry in filteredColumnsPerClonotype {
		column := colEntry.column
		originalIdx := colEntry.originalIndex
		
		if tsvBuilder == undefined {
			tsvBuilder = pframes.tsvFileBuilder().cpu(1).mem("4GiB")
			tsvBuilder.setAxisHeader(column.spec.axesSpec[0], cloneKeyAxisHeader)
		}
		
		// Set axis headers for any axes that are not the main clonotypeKey axis
		for axisIdx, axis in column.spec.axesSpec {
			if axis.name != datasetSpec.axesSpec[1].name {
				// Generate unique axis header name based on column index and axis index
				axisHeaderName := "axis_" + string(columnIndex) + "_" + string(axisIdx)
				tsvBuilder.setAxisHeader(axis, axisHeaderName)
			}
		}
		columnIndex += 1
		
		// Get derived label using original index and ensure it's unique against all previously used labels
		header := derivedLabels[originalIdx]
		if is_undefined(header) {
			// Fallback to base label if derived label is missing
			header = column.spec.annotations["pl7.app/label"]
		}
		header = ensureUniqueLabel(header, usedLabelsSet)
		
		// Update spec with unique header
		updatedSpec := maps.clone(column.spec)
		updatedSpec.annotations["pl7.app/label"] = header
		byCloneSpecs += [updatedSpec]
		
		tsvBuilder.add(column, {header: header})
		columnsInBuilder += 1
		if columnsInBuilder == 4 {
			tsv := tsvBuilder.build()
			pfs += [bigTableWf.frame(tsv, { xsvType: "tsv", inferSchema: false })]
			tsvBuilder = undefined
			columnsInBuilder = 0
		}
	}

	if tsvBuilder != undefined {
		tsv := tsvBuilder.build()
		pfs += [bigTableWf.frame(tsv, { xsvType: "tsv", inferSchema: false })]
	}

	// Collect labels used by columnsPerClonotype to avoid conflicts with linked columns
	usedLabelsFromPerClonotype := []
	for spec in byCloneSpecs {
		if !is_undefined(spec.annotations["pl7.app/label"]) {
			usedLabelsFromPerClonotype = append(usedLabelsFromPerClonotype, spec.annotations["pl7.app/label"])
		}
	}
	
	// Process linked columns
	if !is_undefined(linkedColumns) {
		linkedResult := processLinkedColumns(columnBundle, datasetSpec, linkedColumns, cloneKeyAxisHeader, bigTableWf, byCloneSpecs, usedLabelsFromPerClonotype)
		pfs += linkedResult.frames
		byCloneSpecs = linkedResult.byCloneSpecs
	}

	maps.forEach(perSampleTsvFiles, func(key, tsv) {
		perSamplePf := bigTableWf.frame(tsv, { xsvType: "tsv", inferSchema: false })
		pfs += [perSamplePf]
	})
	ll.assert(len(pfs) > 0, "Expected at least one table, got " + string(len(pfs)))

	//
	// Assembling join tree
	//
	// P0 ──┐
	//      ├─ J01 ──┐
	// P1 ──┘        │
	// P2 ──┐        ├─ J0123 ──┐
	//      ├─ J23 ──┘          │
	// P3 ──┘                   │
	// P4 ──┐                   ├─ J0123456 (Final Result)
	//      ├─ J45 ──┐          │
	// P5 ──┘        ├─ J456 ───┘
	// P6 ───────────┘
	//

	for len(pfs) > 1 {
		nextPerSamplePfs := []
		for i := 1; i < len(pfs); i+=2 {
			pf1 := pfs[i - 1]
			pf2 := pfs[i]
			joined := pf1.join(pf2, { on: cloneKeyAxisHeader, how: "full", coalesce: true })
			nextPerSamplePfs = append(nextPerSamplePfs, joined)
		}
		if len(pfs) % 2 == 1 {
			nextPerSamplePfs = append(nextPerSamplePfs, pfs[len(pfs) - 1])
		}
		pfs = nextPerSamplePfs
	}

	ll.assert(len(pfs) == 1, "Expected exactly one data frame, got " + string(len(pfs)))

	bigTablePf := pfs[0]

	// bigTablePf := perClonotypePf.join(pfs[0], { on: cloneKeyAxisHeader, how: "full", coalesce: true })

	slices.quickSortInPlaceFn(byCloneSpecs, func(a, b) {
		if is_undefined(a.annotations["pl7.app/table/orderPriority"]) {
			return false
		}
		if is_undefined(b.annotations["pl7.app/table/orderPriority"]) {
			return true
		}
		return int(a.annotations["pl7.app/table/orderPriority"]) > int(b.annotations["pl7.app/table/orderPriority"])
	})

	bigTablePf = bigTablePf.select(slices.map(byCloneSpecs + bySampleSpecs, func(spec) {
		return pt.col(spec.annotations["pl7.app/label"])
	})...)
	bigTablePf.save("big_table.tsv")
	bigTableWfResult := bigTableWf.run()
	finalTsv := bigTableWfResult.getFile("big_table.tsv")
	zipResult := exec.builder().
		printErrStreamToStdout().
		software(sevenZipSw).
		cpu(4).
		mem("2GiB").
		addFile("clones.tsv", finalTsv).
		arg("a").
		arg("clones.zip").
		arg("clones.tsv").
		saveFile("clones.zip").
		run()

	return {
		tsvZip: file.exportFile(zipResult.getFile("clones.zip"))
	}
})
