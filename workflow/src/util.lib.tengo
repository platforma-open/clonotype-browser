rand := import("rand")
json := import("json")
ll := import("@platforma-sdk/workflow-tengo:ll")
smart := import("@platforma-sdk/workflow-tengo:smart")
assets := import("@platforma-sdk/workflow-tengo:assets")
render := import("@platforma-sdk/workflow-tengo:render")
pBundle := import("@platforma-sdk/workflow-tengo:pframes.bundle")
sets := import("@platforma-sdk/workflow-tengo:sets")
maps := import("@platforma-sdk/workflow-tengo:maps")
strings := import("@platforma-sdk/workflow-tengo:strings")
canonical := import("@platforma-sdk/workflow-tengo:canonical")

mainFractionColumn := {
	axes: [
		{ anchor: "main", idx: 0 },
		{ anchor: "main", idx: 1 }
	],
	annotations: {
		"pl7.app/isAbundance": "true",
		"pl7.app/abundance/normalized": "true",
		"pl7.app/abundance/isPrimary": "true"
	}
}

mainCountColumn := {
	axes: [
		{ anchor: "main", idx: 0 },
		{ anchor: "main", idx: 1 }
	],
	annotations: {
		"pl7.app/isAbundance": "true",
		"pl7.app/abundance/normalized": "false",
		"pl7.app/abundance/isPrimary": "true"
	}
}

// Extracts all columns from a filter recursively and adds them to the columnsSet
addColumnsFromFilters := func(filter, columnsSet) {
	if is_undefined(filter) {
		return
	}

	ll.assert(is_map(filter), "filter must be a map")

	maybeAddColumn := func(maybeColumn) {
		if is_string(maybeColumn) {
			// It's a direct SUniversalPColumnId
			sets.add(columnsSet, maybeColumn)
		} else if is_map(maybeColumn) && maybeColumn.transformer {
			// It's a TransformedColumn, like ValueRank, SortedCumulativeSum, Log10
			ll.assert(!is_undefined(maybeColumn.column), "TransformedColumn must have a 'column' field")
			sets.add(columnsSet, maybeColumn.column)
		}
		// Ignore if it's a number (constant value in NumericalComparisonFilter)
	}

	if filter.type == "or" || filter.type == "and" {
		// Handle logical OR and AND filters by processing each contained filter
		for _, subFilter in filter.filters {
			addColumnsFromFilters(subFilter, columnsSet)
		}
	} else if filter.type == "not" {
		// Handle NOT filter by processing the contained filter
		addColumnsFromFilters(filter.filter, columnsSet)
	} else if filter.type == "pattern" {
		// Handle PatternFilter
		ll.assert(!is_undefined(filter.column), "PatternFilter must have a 'column' field")
		sets.add(columnsSet, filter.column)
	} else if filter.type == "numericalComparison" {
		// Handle NumericalComparisonFilter
		ll.assert(!is_undefined(filter.lhs), "NumericalComparisonFilter must have an 'lhs' field")
		ll.assert(!is_undefined(filter.rhs), "NumericalComparisonFilter must have an 'rhs' field")
		maybeAddColumn(filter.lhs)
		maybeAddColumn(filter.rhs)
	} else if filter.type == "isNA" {
		// Handle IsNA filter
		ll.assert(!is_undefined(filter.column), "IsNA filter must have a 'column' field")
		sets.add(columnsSet, filter.column)
	}
}

// Extracts all column IDs from an annotationScript and returns them as a list
extractColumnsFromFilter := func(annotationScript) {
	columnsSet := {}

	for _, step in annotationScript.steps {
		addColumnsFromFilters(step.filter, columnsSet)
	}

	return sets.toSlice(columnsSet)
}

createColumnBundle := func(wf, args) {
	// Don't build the bundle if the input anchor is not set
	if is_undefined(args.inputAnchor) {
		return undefined
	}

	bundleBuilder := wf.createPBundleBuilder()

	bundleBuilder.addAnchor("main", args.inputAnchor)

	columns := extractColumnsFromFilter(args.annotationScript)

	for column in columns {
		bundleBuilder.addById(column)
	}

	bundleBuilder.addById(mainFractionColumn)
	bundleBuilder.addById(mainCountColumn)

	return bundleBuilder.build()
}

// Transforms column identifiers inside a filter tree
transformFilterColumns := func(filter, transformFn) {
	if is_undefined(filter) {
		return undefined
	}

	ll.assert(is_map(filter), "filter must be a map")

	transformMaybeColumn := func(maybeColumn) {
		if is_string(maybeColumn) {
			// It's a direct SUniversalPColumnId
			return transformFn(maybeColumn)
		} else if is_map(maybeColumn) && maybeColumn.transformer {
			// It's a TransformedColumn
			return maps.deepTransform(maybeColumn, {
				column: transformFn
			})
		}
		// If it's a number or something else, return as is
		return maybeColumn
	}

	if filter.type == "or" || filter.type == "and" {
		return maps.deepTransform(filter, {
			filters: func(filters) {
				newFilters := []
				for _, subFilter in filters {
					newFilters = append(newFilters, transformFilterColumns(subFilter, transformFn))
				}
				return newFilters
			}
		})
	} else if filter.type == "not" {
		return maps.deepTransform(filter, {
			filter: func(subFilter) {
				return transformFilterColumns(subFilter, transformFn)
			}
		})
	} else if filter.type == "pattern" {
		// Handle PatternFilter
		ll.assert(!is_undefined(filter.column), "PatternFilter must have a 'column' field")
		return maps.deepTransform(filter, {
			column: transformFn
		})
	} else if filter.type == "numericalComparison" {
		// Handle NumericalComparisonFilter
		ll.assert(!is_undefined(filter.lhs), "NumericalComparisonFilter must have an 'lhs' field")
		ll.assert(!is_undefined(filter.rhs), "NumericalComparisonFilter must have an 'rhs' field")
		return maps.deepTransform(filter, {
			lhs: transformMaybeColumn,
			rhs: transformMaybeColumn
		})
	} else if filter.type == "isNA" {
		// Handle IsNA filter
		ll.assert(!is_undefined(filter.column), "IsNA filter must have a 'column' field")
		return maps.deepTransform(filter, {
			column: transformFn
		})
	}

	return filter
}

// Transforms column identifiers inside an annotation script
transformAnnotationScriptColumns := func(annotationScript, transformFn) {
	if is_undefined(annotationScript) {
		return undefined
	}

	return maps.deepTransform(annotationScript, {
		steps: func(steps) {
			newSteps := []
			for _, step in steps {
				newStep := maps.clone(step)
				if !is_undefined(step.filter) {
					newStep.filter = transformFilterColumns(step.filter, transformFn)
				}
				newSteps = append(newSteps, newStep)
			}
			return newSteps
		}
	})
}

// Extracts all unique annotation labels from an annotation script
extractAnnotationLabels := func(annotationScript) {
	if is_undefined(annotationScript) || is_undefined(annotationScript.steps) {
		return []
	}

	labelsSet := {}
	for _, step in annotationScript.steps {
		if is_map(step) && !is_undefined(step.label) {
			sets.add(labelsSet, step.label)
		}
	}
	return sets.toSlice(labelsSet)
}

isExpression := func(v) {
	return !is_undefined(v) && is_map(v) && is_string(v.type)
}

expressionTraverse := func(expression, visitFn) {
	if (!isExpression(expression)) {
		return
	}

	visitFn(expression)

	// Main switch by expression.type
	t := expression.type

	if t == "col" {
		return
	}

	if t == "const" {
		return
	}

	// Comparisons
	if t == "eq" || t == "neq" || t == "gt" || t == "lt" || t == "ge" || t == "le" {
		expressionTraverse(expression.lhs, visitFn)
		expressionTraverse(expression.rhs, visitFn)
		return
	}

	// Boolean logic
	if t == "and" || t == "or" {
		if is_array(expression.operands) {
			for _, op in expression.operands { expressionTraverse(op, visitFn) }
		}
		return
	}
	if t == "not" {
		expressionTraverse(expression.value, visitFn)
		return
	}

	// Arithmetic binary
	if t == "plus" || t == "minus" || t == "multiply" || t == "truediv" || t == "floordiv" {
		expressionTraverse(expression.lhs, visitFn)
		expressionTraverse(expression.rhs, visitFn)
		return
	}

	// Unary math
	if t == "log10" || t == "log" || t == "log2" || t == "abs" || t == "sqrt" || t == "negate" || t == "floor" || t == "round" || t == "ceil" {
		expressionTraverse(expression.value, visitFn)
		return
	}

	if t == "cast" {
		expressionTraverse(expression.value, visitFn)
		return
	}

	// Null checks
	if t == "is_na" || t == "is_not_na" {
		expressionTraverse(expression.value, visitFn)
		return
	}

	// String ops
	if t == "str_join" {
		if is_array(expression.operands) {
			for _, op in expression.operands { expressionTraverse(op, visitFn) }
		}
		return
	}
	if t == "hash" {
		expressionTraverse(expression.value, visitFn)
		return
	}
	if t == "to_upper" || t == "to_lower" || t == "str_len" {
		expressionTraverse(expression.value, visitFn)
		return
	}
	if t == "string_distance" {
		expressionTraverse(expression.string1, visitFn)
		expressionTraverse(expression.string2, visitFn)
		return
	}
	if t == "fuzzy_string_filter" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.pattern) { expressionTraverse(expression.pattern, visitFn) }
		return
	}
	if t == "when_then_otherwise" {
		if is_array(expression.conditions) {
			for _, c in expression.conditions {
				// c expected to be a map with when/then
				if is_map(c) {
					expressionTraverse(c.when, visitFn)
					expressionTraverse(c.then, visitFn)
				}
			}
		}
		expressionTraverse(expression.otherwise, visitFn)
		return
	}
	if t == "substring" {
		expressionTraverse(expression.value, visitFn)
		expressionTraverse(expression.start, visitFn)
		if !is_undefined(expression.length) { expressionTraverse(expression.length, visitFn) }
		if !is_undefined(expression.end) { expressionTraverse(expression.end, visitFn) }
		return
	}
	if t == "str_replace" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.pattern) { expressionTraverse(expression.pattern, visitFn) }
		if isExpression(expression.replacement) { expressionTraverse(expression.replacement, visitFn) }
		return
	}
	if t == "str_contains" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.pattern) { expressionTraverse(expression.pattern, visitFn) }
		return
	}
	if t == "str_starts_with" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.prefix) { expressionTraverse(expression.prefix, visitFn) }
		return
	}
	if t == "str_ends_with" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.suffix) { expressionTraverse(expression.suffix, visitFn) }
		return
	}
	if t == "str_contains_any" {
		expressionTraverse(expression.value, visitFn)
		return
	}
	if t == "str_count_matches" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.pattern) { expressionTraverse(expression.pattern, visitFn) }
		return
	}
	if t == "str_extract" {
		expressionTraverse(expression.value, visitFn)
		if isExpression(expression.pattern) { expressionTraverse(expression.pattern, visitFn) }
		return
	}

	// Aggregations / window / others
	if t == "min" || t == "max" {
		if is_array(expression.operands) {
			for _, op in expression.operands { expressionTraverse(op, visitFn) }
		}
		return
	}
	if t == "fill_null" || t == "fill_nan" {
		expressionTraverse(expression.input, visitFn)
		expressionTraverse(expression.fillValue, visitFn)
		return
	}
	if t == "aggregate" {
		expressionTraverse(expression.value, visitFn)
		if is_array(expression.partitionBy) {
			for _, p in expression.partitionBy { expressionTraverse(p, visitFn) }
		}
		return
	}
	if t == "rank" {
		if is_array(expression.partitionBy) {
			for _, p in expression.partitionBy { expressionTraverse(p, visitFn) }
		}
		if is_array(expression.orderBy) {
			for _, o in expression.orderBy { expressionTraverse(o, visitFn) }
		}
		return
	}
	if t == "cumsum" {
		expressionTraverse(expression.value, visitFn)
		if is_array(expression.additionalOrderBy) {
			for _, o in expression.additionalOrderBy { expressionTraverse(o, visitFn) }
		}
		if is_array(expression.partitionBy) {
			for _, p in expression.partitionBy { expressionTraverse(p, visitFn) }
		}
		return
	}
	if t == "struct_field" {
		expressionTraverse(expression.struct, visitFn)
		return
	}

	// Unknown type: do nothing
}

addColumnsFromExpression := func(expression, columnsSet) {
	expressionTraverse(expression, func(node) {
		if node.type == "col" {
			// Direct column reference
			if is_string(node.name) {
				sets.add(columnsSet, node.name)
			}
			return
		}
	})
}

mapExpressionColumnNames := func(expression, transformFn) {
	copy := maps.clone(expression)
	
	expressionTraverse(copy, func(node) {
		if node.type == "col" {
			// Direct column reference
			if is_string(node.name) {
				node.name = transformFn(node.name)
			}
		}
	})

	return copy
}

extractColumnsFromExpression := func(annotations) {
	columnsSet := {}

	for _, item in annotations.specs {
		addColumnsFromExpression(item.expression, columnsSet)
	}

	return sets.toSlice(columnsSet)
}

createColumnBundle2 := func(wf, args) {
	// Don't build the bundle if the input anchor is not set
	if is_undefined(args.inputAnchor) {
		return undefined
	}

	bundleBuilder := wf.createPBundleBuilder()

	bundleBuilder.addAnchor("main", args.inputAnchor)

	columns := extractColumnsFromExpression(args.annotationSpecs)

	for column in columns {
		bundleBuilder.addById(column)
	}

	bundleBuilder.addById(mainFractionColumn)
	bundleBuilder.addById(mainCountColumn)

	return bundleBuilder.build()
}

createColumnNameManager := func() {
	safeToName := {}

	return {
		toSafe: func(name) {
			safe := strings.substituteSpecialCharacters(name) + "_" + string(rand.int())
			safeToName[safe] = name;
			return safe
		},
		fromSafe: func(safe) {
			return safeToName[safe]
		}
	}
}


export ll.toStrict({
	mainFractionColumn: mainFractionColumn,
	mainCountColumn: mainCountColumn,
	extractColumnsFromFilter: extractColumnsFromFilter,
	createColumnBundle: createColumnBundle,
	transformFilterColumns: transformFilterColumns,
	transformAnnotationScriptColumns: transformAnnotationScriptColumns,
	extractAnnotationLabels: extractAnnotationLabels,

	createColumnBundle2: createColumnBundle2,
	createColumnNameManager: createColumnNameManager,
	mapExpressionColumnNames: mapExpressionColumnNames,
	extractColumnsFromExpression: extractColumnsFromExpression
})
